<!DOCTYPE html>

<html class="" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Spring," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="经过前面的 AOP（面向切面编程） 和 Transaction（事务管理），这次来到了 MVC（Web 应用，进行请求分发和处理） Spring MVC 定义：  分离了控制器（Controller）、模型（Model）、分配器（Adapter）、视图（View）和处理程序对象（Handler，实际上调用的是 Controller 中定义的逻辑）。 基于 Servlet 功能实现，通过实现了 S">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 源码学习(十) Spring mvc">
<meta property="og:url" content="http://yoursite.com/2019/07/21/spring/2019-07-21-spring-analysis-note-10/index.html">
<meta property="og:site_name" content="JingQ">
<meta property="og:description" content="经过前面的 AOP（面向切面编程） 和 Transaction（事务管理），这次来到了 MVC（Web 应用，进行请求分发和处理） Spring MVC 定义：  分离了控制器（Controller）、模型（Model）、分配器（Adapter）、视图（View）和处理程序对象（Handler，实际上调用的是 Controller 中定义的逻辑）。 基于 Servlet 功能实现，通过实现了 S">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/IndiaLitSpace_ZH-CN5941074986_1920x1080.jpg">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/mvc_book_view.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/mvc_responseBody.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/context_loader_listener_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/dispatcher_servlet_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/context_class_setting.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/xml_web_applicaiton_context_refresh_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/spring_mvc_loading_config_locations.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/theme_reslover_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/default_handler_mapping_init_process.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/request_mapping_handler_mapping_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/registry_mapping_method_mapping.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/http_framework_servlet_enter.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/view_name_method_return_value_handler_diagram.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/get_model_and_view_process.png">
<meta property="og:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/jstl_diagram.png">
<meta property="og:updated_time" content="2021-10-30T17:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring 源码学习(十) Spring mvc">
<meta name="twitter:description" content="经过前面的 AOP（面向切面编程） 和 Transaction（事务管理），这次来到了 MVC（Web 应用，进行请求分发和处理） Spring MVC 定义：  分离了控制器（Controller）、模型（Model）、分配器（Adapter）、视图（View）和处理程序对象（Handler，实际上调用的是 Controller 中定义的逻辑）。 基于 Servlet 功能实现，通过实现了 S">
<meta name="twitter:image" content="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/IndiaLitSpace_ZH-CN5941074986_1920x1080.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'JingQ'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/21/spring/2019-07-21-spring-analysis-note-10/"/>





  <title>Spring 源码学习(十) Spring mvc | JingQ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JingQ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-javatech">
          <a href="http://www.justdojava.com/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Java Geek Tech
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/spring/2019-07-21-spring-analysis-note-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JingQ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gitee.com/vip-augus/blog-picture/raw/master/panda.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JingQ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring 源码学习(十) Spring mvc</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T11:12:00+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 游览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/IndiaLitSpace_ZH-CN5941074986_1920x1080.jpg" alt=""></p>
<p><strong>经过前面的 <code>AOP</code>（面向切面编程） 和 <code>Transaction</code>（事务管理），这次来到了 <code>MVC</code>（Web 应用，进行请求分发和处理）</strong></p>
<p><strong>Spring MVC 定义：</strong></p>
<blockquote>
<p>分离了控制器（Controller）、模型（Model）、分配器（Adapter）、视图（View）和处理程序对象（Handler，实际上调用的是 Controller 中定义的逻辑）。</p>
<p>基于 Servlet 功能实现，通过实现了 Servlet 接口的 DispatcherServlet 来封装其核心功能实现，通过将请求分派给处理程序，同时带有可配置的处理程序映射、视图解析、本地语言、主题解析以及上传文件支持。</p>
</blockquote>
<p><strong>同样老套路，本篇按照以下思路展开：</strong></p>
<p><strong>(1) 介绍如何使用</strong></p>
<p><strong>(2) 辅助工具类 <code>ContextLoaderContext</code></strong></p>
<p><strong>(3) <code>DispatcherServlet</code> 初始化</strong></p>
<p><strong>(4) <code>DispatcherServlet</code> 处理请求</strong></p>
<a id="more"></a>
<hr>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>代码结构如下：(详细代码可在文章末尾下载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">├── java</div><div class="line">│   ├── domains</div><div class="line">│   └── web</div><div class="line">│       └── controller</div><div class="line">│           └── BookController.java</div><div class="line">├── resources</div><div class="line">│   └── configs</div><div class="line">└── webapp</div><div class="line">│   └── WEB-INF</div><div class="line">│       ├── views</div><div class="line">│       │   ├── bookView.jsp</div><div class="line">│       │   └── index.jsp</div><div class="line">├──     ├── applicationContext.xml</div><div class="line">│       ├── spring-mvc.xml</div><div class="line">│       └── web.xml</div><div class="line">└── build.gradle</div></pre></td></tr></table></figure>
<p>（1）<strong>配置 <code>web.xml</code></strong></p>
<p>在该文件中，主要配置了两个关键点：</p>
<p><strong>1. <code>contextConfigLocation</code> ：使 <code>Web</code> 和 <code>Spring</code> 的配置文件相结合的关键配置</strong></p>
<p><strong>2. <code>DispatcherServlet</code> : 包含了 <code>SpringMVC</code> 的请求逻辑，使用该类拦截 <code>Web</code> 请求并进行相应的逻辑处理</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></div><div class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></div><div class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 使用 ContextLoaderListener时,告诉它 Spring 配置文件地址 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用监听器加载 applicationContext 文件 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 配置 DispatcherServlet --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用 <code>IDEA</code> 时，尽量选择默认条件和自动扫描加载 <code>Web</code> 配置文件，然后添加 <code>tomcat</code> 进行启动，具体配置请查阅 <a href="https://www.jianshu.com/p/7fe31ea61dda" target="_blank" rel="noopener">idea 创建java web项目ssm-gradle</a></p>
<hr>
<p>(2) 配置 <code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!--这里比较简单，只是通知 Spring 扫描对应包下的 bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"web.controller"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以在这里自定义想要加载的 <code>bean</code>，或者设置数据库数据源、事务管理器等等 <code>Spring</code> 应用配置。</p>
<hr>
<p>(3) 配置 <code>spring-mvc.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context</span></span></div><div class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--扫描包,自动注入bean--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"web.controller"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--使用注解开发spring mvc--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用了 <code>InternalResourceViewResolver</code>，它是一个辅助 <code>Bean</code>，这样配置的意图是：<br><strong>在 <code>ModelAndView</code> 返回的视图名前加上 <code>prefix</code> 指定的前缀和 <code>suffix</code> 的后缀（我理解为用来解析和返回视图，以及将视图层进行统一管理，放到指定路径中）</strong></p>
<hr>
<p>(4) 创建 <code>BookController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, method = RequestMethod.GET)</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"bookView"</span>, method = RequestMethod.GET)</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">helloView</span><span class="params">(Model model)</span> </span>&#123;</div><div class="line">		ComplexBook book1 = <span class="keyword">new</span> ComplexBook(<span class="string">"Spring 源码深度分析"</span>, <span class="string">"技术类"</span>);</div><div class="line">		ComplexBook book2 = <span class="keyword">new</span> ComplexBook(<span class="string">"雪国"</span>, <span class="string">"文学类"</span>);</div><div class="line">		List&lt;ComplexBook&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</div><div class="line">		list.add(book1);</div><div class="line">		list.add(book2);</div><div class="line">		model.addAttribute(<span class="string">"bookList"</span>, list);</div><div class="line">		<span class="keyword">return</span> <span class="string">"bookView"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"plain"</span>)</div><div class="line">	<span class="meta">@ResponseBody</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">plain</span><span class="params">(@PathVariable String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，与书中示例并不一样，使用的是更贴合我们实际开发中用到的 <code>@RequestMapping</code> 等注解作为例子。根据请求的 <code>URL</code> 路径，匹配到对应的方法进行处理。</p>
<hr>
<p>(5) 创建 <code>jsp</code> 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">index.jsp</div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello JingQ!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line">---</div><div class="line">bookView.jsp</div><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Book Shop<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;bookList&#125;"</span> <span class="attr">var</span>=<span class="string">"book"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;book.name&#125;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;book.tag&#125;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>按照现在前后端分离的大趋势，我其实并不想用 <code>jsp</code> 视图技术作为例子，但考虑到之前入门时也接触过，也为了跟我一样不会写前端的同学更好理解，所以还是记录一下如何使用 <code>jsp</code>。</p>
<hr>
<p>(6) 添加依赖 <code>build.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入 spring-web 和 spring-webmvc，如果不是跟我一样使用源码进行编译，请到 mvn 仓库中寻找对应依赖</span></div><div class="line">optional(<span class="keyword">project</span>(<span class="string">":spring-web"</span>))</div><div class="line">optional(<span class="keyword">project</span>(<span class="string">":spring-webmvc"</span>))</div><div class="line"></div><div class="line"><span class="comment">// 引入这个依赖，使用 jsp 语法 https://mvnrepository.com/artifact/javax.servlet/jstl</span></div><div class="line"><span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'javax.servlet'</span>, name: <span class="string">'jstl'</span>, version: <span class="string">'1.2'</span></div></pre></td></tr></table></figure>
<hr>
<p>(7) 启动 <code>Tomcat</code><br>如何配置和启动，网上也有很多例子，参考资料 3 是个不错的例子，下面是请求处理结果：</p>
<blockquote>
<p><a href="http://localhost:8080/bookView" target="_blank" rel="noopener">http://localhost:8080/bookView</a>   (使用了 JSP 视图进行渲染）</p>
</blockquote>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/mvc_book_view.png" alt=""></p>
<blockquote>
<p><a href="http://localhost:8080/plain/value" target="_blank" rel="noopener">http://localhost:8080/plain/value</a> （前后端分离的话，常用的是这种，最后可以返回简单字符或者 json 格式的对象等）</p>
</blockquote>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/mvc_responseBody.png" alt=""></p>
<p>在刚才的 <code>web.xml</code> 中有两个关键配置，所以现在学习下这两个配置具体是干啥的。</p>
<hr>
<h1 id="ContextLoaderContext"><a href="#ContextLoaderContext" class="headerlink" title="ContextLoaderContext"></a>ContextLoaderContext</h1><p><strong>作用：在启动 <code>web</code> 容器时，自动装载 <code>ApplicationContext</code> 的配置信息。</strong></p>
<p>下面是它的继承体系图：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/context_loader_listener_diagram.png" alt=""></p>
<p>这是一个辅助工具类，可以用来传递配置信息参数，在 <code>web.xml</code> 中，将路径以 <code>context-param</code> 的方式注册并使用 <code>ContextLoaderListener</code> 进行监听读取。 </p>
<p><strong>从图中能看出，它实现了 <code>ServletContextListener</code> 这个接口，只要在 <code>web.xml</code> 配置了这个监听器，容器在启动时，就会执行 <code>contextInitialized(ServletContextEvent)</code> 这个方法，进行应用上下文初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">	initWebApplicationContext(event.getServletContext());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个 <code>Web</code> 应用都会有一个 <code>ServletContext</code> 贯穿生命周期（<strong>在应用启动时创建，关闭时销毁</strong>），跟 <code>Spring</code> 中 <code>ApplicationContext</code> 类似，在全局范围内有效。</p>
<p>实际上初始化的工作，是由父类 <code>ContextLoader</code> 完成的：(简略版）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</div><div class="line">    <span class="comment">// demo 中用到的根容器是 Spring 容器 WebApplicationContext.class.getName() + ".ROOT"</span></div><div class="line">	<span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// web.xml 中存在多次 ContextLoader 定义</span></div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">    <span class="comment">// 将上下文存储在本地实例变量中，以保证在 ServletContext 关闭时可用。</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="comment">// 初始化 context</span></div><div class="line">    	<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">    	ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</div><div class="line">    	<span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">    		<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">    			ApplicationContext parent = loadParentContext(servletContext);</div><div class="line">    			cwac.setParent(parent);</div><div class="line">    		&#125;</div><div class="line">    		configureAndRefreshWebApplicationContext(cwac, servletContext);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 记录在 ServletContext 中</span></div><div class="line">    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</div><div class="line">    ClassLoader ccl = Thread.currentThread().getContextClassLoader();</div><div class="line">    <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</div><div class="line">    	currentContext = <span class="keyword">this</span>.context;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</div><div class="line">    	currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">    	<span class="comment">// 计数器，计算初始化耗时时间</span></div><div class="line">    	<span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</div><div class="line">    	logger.info(<span class="string">"Root WebApplicationContext initialized in "</span> + elapsedTime + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数主要是体现了创建 <code>WebApplicationContext</code> 实例的一个功能架构，实现的大致步骤如下：</p>
<p><strong>1. <code>WebApplicationContext</code> 存在性的验证：</strong><br>只能初始化一次，如果有多个声明，将会扰乱 <code>Spring</code> 的执行逻辑，所以有多个声明将会报错。<br><strong>2. 创建 <code>WebApplicationContext</code> 实例：</strong><br><code>createWebApplicationContext(servletContext);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</div><div class="line">    <span class="comment">// defaultStrategies 是个静态变量，在静态代码块中初始化</span></div><div class="line">    contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</div><div class="line">	<span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 默认策略</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 从 ContextLoader.properties 文件中加载默认策略</span></div><div class="line">		<span class="comment">// 在这个目录下：org/springframework/web/context/ContextLoader.properties</span></div><div class="line">		ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</div><div class="line">		defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'ContextLoader.properties': "</span> + ex.getMessage());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</div></pre></td></tr></table></figure>
<p>如果按照默认策略，它将会从配置文件 <code>ContextLoader.properties</code> 中读取需要创建的实现类：<code>XmlWebApplicationContext</code></p>
<p><strong>3. 将实例记录在 <code>servletContext</code> 中</strong><br><strong>4. 映射当前的类加载器与创建的实例到全局变量 <code>currentContextPerThread</code> 中</strong></p>
<p>通过以上步骤，完成了创建 <code>WebApplicationContext</code> 实例，它继承自 <code>ApplicaitonContext</code>，在父类的基础上，追加了一些特定于 <code>web</code> 的操作和属性，可以把它当成我们之前初始化 <code>Spring</code> 容器时所用到的 <code>ClassPathApplicaitonContext</code> 那样使用。</p>
<hr>
<h1 id="DispatcherServlet-初始化"><a href="#DispatcherServlet-初始化" class="headerlink" title="DispatcherServlet 初始化"></a>DispatcherServlet 初始化</h1><p>该类是 <code>spring-mvc</code> 的核心，该类进行真正逻辑实现，<code>DisptacherServlet</code> 实现了 <code>Servlet</code> 接口。</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/dispatcher_servlet_diagram.png" alt=""></p>
<p><strong>介绍：</strong></p>
<blockquote>
<p><code>servlet</code> 是一个 <code>Java</code> 编写的程序，基于 <code>Http</code> 协议，例如我们常用的 <code>Tomcat</code>，也是按照 <code>servlet</code> 规范编写的一个 <code>Java</code> 类</p>
<p><code>servlet</code> 的生命周期是由 <code>servlet</code> 的容器来控制，<strong>分为三个阶段：初始化、运行和销毁。</strong></p>
</blockquote>
<p>在 <code>servlet</code> 初始化阶段会调用其 <code>init</code> 方法：</p>
<blockquote>
<p>HttpServletBean#init</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	<span class="comment">// 解析 init-param 并封装到 pvs 变量中</span></div><div class="line">	PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">	<span class="comment">// 将当前的这个 Servlet 类转换为一个 BeanWrapper，从而能够以 Spring 的方式对 init—param 的值注入</span></div><div class="line">	BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">	ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</div><div class="line">	<span class="comment">// 注册自定义属性编辑器，一旦遇到 Resource 类型的属性将会使用 ResourceEditor 进行解析</span></div><div class="line">	bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">	<span class="comment">// 空实现，留给子类覆盖</span></div><div class="line">	initBeanWrapper(bw);</div><div class="line">	bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">	<span class="comment">// 初始化 servletBean （让子类实现，这里它的实现子类是 FrameworkServlet）</span></div><div class="line">	initServletBean();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里初始化 <code>DispatcherServlet</code>，主要是通过将当前的 <code>servlet</code> 类型实例转换为 <code>BeanWrapper</code> 类型实例，以便使用 <code>Spring</code> 中提供的注入功能进行相应属性的注入。</p>
<p>从上面注释，可以看出初始化函数的逻辑比较清晰，<strong>封装参数、转换成 <code>BeanWrapper</code> 实例、注册自定义属性编辑器、属性注入，以及关键的初始化 <code>servletBean</code>。</strong></p>
<hr>
<h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><p>下面看下初始化关键逻辑：</p>
<blockquote>
<p>FrameworkServlet#initServletBean</p>
</blockquote>
<p>剥离了日志打印后，剩下的两行关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	<span class="comment">// 仅剩的两行关键代码</span></div><div class="line">	<span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</div><div class="line">	<span class="comment">// 留给子类进行覆盖实现，但我们例子中用的 DispatcherServlet 并没有覆盖，所以先不用管它</span></div><div class="line">	initFrameworkServlet();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="WebApplicationContext-的初始化"><a href="#WebApplicationContext-的初始化" class="headerlink" title="WebApplicationContext 的初始化"></a>WebApplicationContext 的初始化</h3><blockquote>
<p>FrameworkServlet#initWebApplicationContext</p>
</blockquote>
<p>该函数的主要工作就是创建或刷新 <code>WebApplicationContext</code> 实例并对 <code>servlet</code> 功能所使用的变量进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 从根容器开始查找</span></div><div class="line">	WebApplicationContext rootContext =</div><div class="line">			WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">	WebApplicationContext wac = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 有可能在 Spring 加载 bean 时，DispatcherServlet 作为 bean 加载进来了</span></div><div class="line">		<span class="comment">// 直接使用在构造函数被注入的 context 实例</span></div><div class="line">		wac = <span class="keyword">this</span>.webApplicationContext;</div><div class="line">		<span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">					cwac.setParent(rootContext);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 刷新上下文环境</span></div><div class="line">				configureAndRefreshWebApplicationContext(cwac);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 根据 contextAttribute 属性加载 WebApplicationContext</span></div><div class="line">		wac = findWebApplicationContext();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 经过上面步骤都没找到，那就来创建一个</span></div><div class="line">		wac = createWebApplicationContext(rootContext);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</div><div class="line">			<span class="comment">// 刷新，初始化很多策略方法</span></div><div class="line">			onRefresh(wac);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</div><div class="line">		<span class="comment">// Publish the context as a servlet context attribute.</span></div><div class="line">		String attrName = getServletContextAttributeName();</div><div class="line">		getServletContext().setAttribute(attrName, wac);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="根容器查找"><a href="#根容器查找" class="headerlink" title="根容器查找"></a>根容器查找</h3><p>我们最常用到的 <code>spring-mvc</code>，是 <code>spring</code> 容器和 <code>web</code> 容器共存，这时 <code>rootContext</code> 父容器就是 <code>spring</code> 容器。</p>
<p>在前面的 <code>web.xml</code> 配置的监听器 <code>ContextLaoderListener</code>，已经将 <code>Spring</code> 父容器进行了加载</p>
<blockquote>
<p>WebApplicationContextUtils#getWebApplicationContext(ServletContext)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</div><div class="line">	<span class="comment">// key 值 ：WebApplicationContext.class.getName() + ".ROOT"</span></div><div class="line">	<span class="comment">// (ServletContext) sc.getAttribute(attrName) ,</span></div><div class="line">	<span class="keyword">return</span> getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，根据上面代码，了解到 <code>Spring</code> 父容器，是以 <code>key</code> 值为 : <code>WebApplicationContext.class.getName() + &quot;.ROOT&quot;</code> 保存到 <code>ServletContext</code> 上下文中。</p>
<hr>
<h3 id="根据-contextAttribute-寻找"><a href="#根据-contextAttribute-寻找" class="headerlink" title="根据 contextAttribute 寻找"></a>根据 contextAttribute 寻找</h3><p>虽然有默认 <code>key</code>，但用户可以重写初始化逻辑（在 <code>web.xml</code> 文件中设定 <code>servlet</code> 参数 <code>contextAttribute</code>），使用自己创建的 <code>WebApplicaitonContext</code>，并在 <code>servlet</code> 的配置中通过初始化参数 <code>contextAttribute</code> 指定 <code>key</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">findWebApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">	String attrName = getContextAttribute();</div><div class="line">	<span class="keyword">if</span> (attrName == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// attrName 就是用户在`web.xml` 文件中设定的 `servlet` 参数 `contextAttribute`</span></div><div class="line">	WebApplicationContext wac =</div><div class="line">			WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName);</div><div class="line">	<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No WebApplicationContext found: initializer not registered?"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="重新创建实例"><a href="#重新创建实例" class="headerlink" title="重新创建实例"></a>重新创建实例</h3><p>通过前面的方法都没找到，那就来重新创建一个新的实例：</p>
<blockquote>
<p>FrameworkServlet#createWebApplicationContext(WebApplicationContext)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable WebApplicationContext parent)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</div><div class="line">	<span class="comment">// 允许我们自定义容器的类型，通过 contextClass 属性进行配置</span></div><div class="line">	<span class="comment">// 但是类型必须要继承 ConfigurableWebApplicationContext，不然将会报错</span></div><div class="line">	Class&lt;?&gt; contextClass = getContextClass();</div><div class="line">	<span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 通过反射来创建 contextClass</span></div><div class="line">	ConfigurableWebApplicationContext wac =</div><div class="line">			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</div><div class="line">	wac.setEnvironment(getEnvironment());</div><div class="line">	wac.setParent(parent);</div><div class="line">	<span class="comment">// 获取 contextConfigLocation 属性，配置在 servlet 初始化函数中</span></div><div class="line">	String configLocation = getContextConfigLocation();</div><div class="line">    wac.setConfigLocation(configLocation);</div><div class="line">	<span class="comment">// 初始化 Spring 环境包括加载配置环境</span></div><div class="line">	configureAndRefreshWebApplicationContext(wac);</div><div class="line">	<span class="keyword">return</span> wac;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="获取上下文类-contextClass"><a href="#获取上下文类-contextClass" class="headerlink" title="获取上下文类 contextClass"></a>获取上下文类 contextClass</h4><p><strong>默认使用的是 <code>XmlWebApplicationContext</code>，但如果需要配置自定义上下文，可以在 <code>web.xml</code> 中的 <code>&lt;init-param&gt;</code> 标签中修改 <code>contextClass</code> 属性对应的 <code>value</code>，但需要注意图中提示：</strong></p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/context_class_setting.png" alt=""></p>
<hr>
<h4 id="configureAndRefreshWebApplicationContext"><a href="#configureAndRefreshWebApplicationContext" class="headerlink" title="configureAndRefreshWebApplicationContext"></a>configureAndRefreshWebApplicationContext</h4><p>使用该方法，用来对已经创建的 <code>WebApplicaitonContext</code> 进行配置以及刷新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</div><div class="line">    <span class="comment">// 遍历 ApplicationContextInitializer，执行 initialize 方法</span></div><div class="line">	applyInitializers(wac);</div><div class="line">	<span class="comment">// 关键的刷新，加载配置文件及整合 parent 到 wac</span></div><div class="line">	wac.refresh();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h4><p>该类可以通过 <code>&lt;init-param&gt;</code> 的 <code>contextInitializerClasses</code> 进行自定义配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextInitializerClasses<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>自定义类，需继承于 `ApplicationContextInitializer`<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p>正如代码中的顺序一样，是在 <code>mvc</code> 容器创建前，执行它的 <code>void initialize(C applicationContext)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext wac)</span> </span>&#123;</div><div class="line">    AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.contextInitializers);</div><div class="line">	<span class="keyword">for</span> (ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; initializer : <span class="keyword">this</span>.contextInitializers) &#123;</div><div class="line">		initializer.initialize(wac);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有如果没有配置的话，默认情况下 <code>contextInitializers</code> 列表为空，表示没有 <code>ApplicationContextInitializer</code> 需要执行。</p>
<hr>
<h4 id="加载-Spring-配置"><a href="#加载-Spring-配置" class="headerlink" title="加载 Spring 配置"></a>加载 Spring 配置</h4><p><code>wac.refresh()</code>，实际调用的是我们之前就很熟悉的刷新方法：</p>
<blockquote>
<p>org.springframework.context.support.AbstractApplicationContext#refresh</p>
</blockquote>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/xml_web_applicaiton_context_refresh_diagram.png" alt="xml_web_applicaiton_context_refresh_diagram"></p>
<p>从图中能够看出，刷新方法的代码逻辑与之前一样，通过父类 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法，进行了配置文件的加载。</p>
<p>在例子中的 <code>web.xml</code> 配置中，指定了加载 <code>spring-mvc.xml</code> 配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置 DispatcherServlet --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="注册-mvc-解析器"><a href="#注册-mvc-解析器" class="headerlink" title="注册 mvc 解析器"></a>注册 mvc 解析器</h4><p>由于我们配置了 <code>contextConfigLocation</code>，指定了加载资源的路径，所以在 <code>XmlWebApplicationContext</code> 初始化的时候，加载的 <code>Spring</code> 配置文件路径是我们指定 <code>spring-mvc.xml</code>：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/spring_mvc_loading_config_locations.png" alt=""></p>
<p>在 <code>spring-mvc.xml</code> 配置中，主要配置了三项</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--扫描包,自动注入bean--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"web.controller"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!--使用注解开发spring mvc--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同样老套路，使用了 <code>&lt;mvc:annotation&gt;</code> 自定义注解的话，要注册相应的解析器后，<code>Spring</code> 容器才能解析元素：</p>
<blockquote>
<p>org.springframework.web.servlet.config.MvcNamespaceHandler</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// MVC 标签解析需要注册的解析器</span></div><div class="line">	registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"interceptors"</span>, <span class="keyword">new</span> InterceptorsBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"resources"</span>, <span class="keyword">new</span> ResourcesBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"view-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"redirect-view-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"status-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"view-resolvers"</span>, <span class="keyword">new</span> ViewResolversBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"tiles-configurer"</span>, <span class="keyword">new</span> TilesConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"freemarker-configurer"</span>, <span class="keyword">new</span> FreeMarkerConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"groovy-configurer"</span>, <span class="keyword">new</span> GroovyMarkupConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"script-template-configurer"</span>, <span class="keyword">new</span> ScriptTemplateConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(<span class="string">"cors"</span>, <span class="keyword">new</span> CorsBeanDefinitionParser());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>mvc</code> 提供了很多便利的注解，有拦截器、资源、视图等解析器，但我们常用的到的是 <code>anntation-driven</code> 注解驱动，这个注解通过 <code>AnnotationDrivenBeanDefinitionParser</code> 类进行解析，其中会注册两个重要的 <code>bean</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>跳过其他熟悉的 <code>Spring</code> 初始化配置，通过上面的步骤，完成了 <code>Spring</code> 配置文件的解析，将扫描到的 <code>bean</code> 加载到了 <code>Spring</code> 容器中。</strong></p>
<p>那么下面就正式进入 <code>mvc</code> 的初始化。</p>
<hr>
<h2 id="mvc-初始化"><a href="#mvc-初始化" class="headerlink" title="mvc 初始化"></a>mvc 初始化</h2><p><strong><code>onRefresh</code> 方法是 <code>FrameworkServlet</code> 类中提供的模板方法，在子类 <code>DispatcherServlet</code> 进行了重写，主要用来刷新 <code>Spring</code> 在 <code>Web</code> 功能实现中所必须用到的全局变量：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">	initStrategies(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">	<span class="comment">// 初始化 multipartResolver 文件上传相关</span></div><div class="line">	initMultipartResolver(context);</div><div class="line">	<span class="comment">// 初始化 LocalResolver 与国际化相关</span></div><div class="line">	initLocaleResolver(context);</div><div class="line">	<span class="comment">// 初始化 ThemeResolver 与主题更换相关</span></div><div class="line">	initThemeResolver(context);</div><div class="line">	<span class="comment">// 初始化 HandlerMapping 与匹配处理器相关</span></div><div class="line">	initHandlerMappings(context);</div><div class="line">	<span class="comment">// 初始化 HandlerAdapter 处理当前 Http 请求的处理器适配器实现，根据处理器映射返回相应的处理器类型</span></div><div class="line">	initHandlerAdapters(context);</div><div class="line">	<span class="comment">// 初始化 HandlerExceptionResolvers，处理器异常解决器</span></div><div class="line">	initHandlerExceptionResolvers(context);</div><div class="line">	<span class="comment">// 初始化 RequestToViewNameTranslator，处理逻辑视图名称</span></div><div class="line">	initRequestToViewNameTranslator(context);</div><div class="line">	<span class="comment">// 初始化 ViewResolver 选择合适的视图进行渲染</span></div><div class="line">	initViewResolvers(context);</div><div class="line">	<span class="comment">// 初始化 FlashMapManager 使用 flash attributes 提供了一个请求存储属性，可供其他请求使用（重定向时常用）</span></div><div class="line">	initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数是实现 <code>mvc</code> 的关键所在，先来大致介绍一下初始化的套路：</p>
<ol>
<li><strong>寻找用户自定义配置</strong></li>
<li><strong>没有找到，使用默认配置</strong></li>
</ol>
<p><strong>显然，<code>Spring</code> 给我们提供了高度的自定义，可以手动设置想要的解析器，以便于扩展功能。</strong></p>
<p><strong>如果没有找到用户配置的 <code>bean</code>，那么它将会使用默认的初始化策略: <code>getDefaultStrategies</code> 方法</strong></p>
<hr>
<h3 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h3><blockquote>
<p>DispatcherServlet#getDefaultStrategies（缩减版）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</div><div class="line">	<span class="comment">// 策略接口名称</span></div><div class="line">	String key = strategyInterface.getName();</div><div class="line">	<span class="comment">// 默认策略列表</span></div><div class="line">	String value = defaultStrategies.getProperty(key);</div><div class="line">	String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</div><div class="line">	List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.length);</div><div class="line">	<span class="keyword">for</span> (String className : classNames) &#123;</div><div class="line">		<span class="comment">// 实例化</span></div><div class="line">		Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</div><div class="line">		Object strategy = createDefaultStrategy(context, clazz);</div><div class="line">		strategies.add((T) strategy);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> strategies;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 默认策略列表</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">	<span class="comment">// 路径名称是：DispatcherServlet.properties</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</div><div class="line">		defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>从静态默认策略属性 <code>defaultStrategies</code> 的加载过程中，读取的是 <code>DispatcherServlet.properties</code> 文件内容，看完下面列出来的信息，相信你跟我一样恍然大悟，了解 <code>Spring</code> 配置了哪些默认策略：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</div><div class="line">	org.springframework.web.servlet.function.support.RouterFunctionMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</div><div class="line">	org.springframework.web.servlet.function.support.HandlerFunctionAdapter</div><div class="line"></div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</div><div class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>
<p>接下来看看它们各自的初始化过程以及使用场景：</p>
<hr>
<h3 id="multipartResolver-文件上传相关"><a href="#multipartResolver-文件上传相关" class="headerlink" title="multipartResolver 文件上传相关"></a>multipartResolver 文件上传相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</div><div class="line">	<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</div><div class="line">		<span class="comment">// Default is no multipart resolver.</span></div><div class="line">		<span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下，<code>Spring</code> 是没有 <code>mulitpart</code> 处理，需要自己设定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--上传下载--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>注册的 <code>id</code> 为 <code>multipartResolver</code></p>
<hr>
<h3 id="LocalResolver-与国际化相关"><a href="#LocalResolver-与国际化相关" class="headerlink" title="LocalResolver 与国际化相关"></a>LocalResolver 与国际化相关</h3><p><code>LocalResolver</code> 接口定义了如何获取客户端的地区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLocaleResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	    <span class="keyword">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</div><div class="line">    	<span class="comment">// We need to use the default.</span></div><div class="line">    	<span class="keyword">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过寻找 <code>id</code> 为 <code>localeResolver</code> 的 <code>bean</code>，如果没有的话，将会使用默认的策略进行加载 <code>AcceptHeaderLocaleResolver</code>，它是基于 <code>URL</code> 参数来控制国际化，例如使用 <code>&lt;a href=&quot;?locale=zh_CN&quot;&gt;</code>  来设定简体中文，默认参数名为 <code>locale</code>。</p>
<p>当然还有其他两种，基于 <code>session</code> 和基于 <code>cookie</code> 的配置，想要深入了解的可以去细看~</p>
<hr>
<h3 id="ThemeResolver-主题更换相关"><a href="#ThemeResolver-主题更换相关" class="headerlink" title="ThemeResolver 主题更换相关"></a>ThemeResolver 主题更换相关</h3><p>主题是一组静态资源（例如样式表 css 和图片 image），也可以理解为应用皮肤，使用 <code>Theme</code> 更改主题风格，改善用户体验。</p>
<p>默认注册的 <code>id</code> 是 <code>themeResolver</code>，类型是 <code>FixedThemeResolver</code>，表示使用的是一个固定的主题，以下是它的继承体系图：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/theme_reslover_diagram.png" alt=""></p>
<p>工作原理是通过拦截器拦截，配置对应的主题解析器，然后返回主题名称，还是使用上面的解析器作为例子：</p>
<blockquote>
<p>FixedThemeResolver#resolveThemeName</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveThemeName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> getDefaultThemeName();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultThemeName</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.defaultThemeName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="HandlerMapping-与匹配处理器相关"><a href="#HandlerMapping-与匹配处理器相关" class="headerlink" title="HandlerMapping 与匹配处理器相关"></a>HandlerMapping 与匹配处理器相关</h3><p>首先判断 <code>detectAllHandlerMappings</code> 变量是否为 <code>true</code>，表示是否需要加载容器中所有的 <code>HandlerMapping</code>，<code>false</code> 将会加载用户配置的。</p>
<p><strong>如注释所说，至少得保证有一个 <code>HandlerMapping</code>，如果前面两个分支都没寻找到，那么就进行默认策略加载。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</div><div class="line">		<span class="comment">// 默认情况下，寻找应用中所有的 HandlerMapping ，包括祖先容器（其实就是 Spring 容器啦）</span></div><div class="line">		Map&lt;String, HandlerMapping&gt; matchingBeans =</div><div class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</div><div class="line">			<span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</div><div class="line">			<span class="comment">// handlerMapping 有优先级，需要排序</span></div><div class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 从上下文中，获取名称为 handlerMapping 的 bean</span></div><div class="line">		HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</div><div class="line">		<span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 需要保证，至少有一个 HandlerMapping</span></div><div class="line">	<span class="comment">// 如果前面两步都没找到 mapping，将会由这里加载默认策略</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>Debug</code> 得知，之前在加载 <code>Spring</code> 配置时，就已经注入了 <code>RequestMappingHandlerMapping</code> 和 <code>BeanNameUrlHandlerMapping</code></p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/default_handler_mapping_init_process.png" alt=""></p>
<hr>
<h3 id="HandlerAdapter-适配器"><a href="#HandlerAdapter-适配器" class="headerlink" title="HandlerAdapter 适配器"></a>HandlerAdapter 适配器</h3><p>套路与前面的一样，使用的默认策略是：<code>HttpRequestHandlerAdapter</code> 、<code>SimpleControllerHandlerAdapter</code>、 <code>RequestMappingHandlerAdapter</code> 和 <code>HandlerFunctionAdapter</code>。</p>
<p>说到适配器，可以将它理解为，将一个类的接口适配成用户所期待的，将两个接口不兼容的工作类，通过适配器连接起来。</p>
<hr>
<h3 id="HandlerExceptionResolver-处理器异常解决器"><a href="#HandlerExceptionResolver-处理器异常解决器" class="headerlink" title="HandlerExceptionResolver 处理器异常解决器"></a>HandlerExceptionResolver 处理器异常解决器</h3><p>套路也与前面一样，使用的默认策略是：<code>ExceptionHandlerExceptionResolver</code>、 <code>ResponseStatusExceptionResolver</code> 和 <code>DefaultHandlerExceptionResolver</code>。</p>
<p>实现了 <code>HandlerExceptionResolver</code> 接口的 <code>resolveException</code> 方法，在方法内部对异常进行判断，然后尝试生成 <code>ModelAndView</code> 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">		HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (shouldApplyTo(request, handler)) &#123;</div><div class="line">		prepareResponse(ex, response);</div><div class="line">		ModelAndView result = doResolveException(request, response, handler, ex);</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="RequestToViewNameTranslator-处理逻辑视图名称"><a href="#RequestToViewNameTranslator-处理逻辑视图名称" class="headerlink" title="RequestToViewNameTranslator 处理逻辑视图名称"></a>RequestToViewNameTranslator 处理逻辑视图名称</h3><p>初始化代码逻辑与前面一样，使用的默认策略是：<code>DefaultRequestToViewNameTranslator</code></p>
<p><strong>使用场景：当 <code>Controller</code> 处理器方法没有返回逻辑视图名称时，<code>Spring</code> 通过该类的约定，提供一个逻辑视图名称。</strong></p>
<p>由于本地测试不出来，所以引用参考资料 7 的例子：</p>
<blockquote>
<p>DefaultRequestToViewNameTranslator的转换例子:</p>
<p><a href="http://localhost:8080/gamecast/display.html" target="_blank" rel="noopener">http://localhost:8080/gamecast/display.html</a> -&gt; display(视图)</p>
</blockquote>
<hr>
<h3 id="ViewResolver-视图渲染"><a href="#ViewResolver-视图渲染" class="headerlink" title="ViewResolver 视图渲染"></a>ViewResolver 视图渲染</h3><p>套路还是跟前面一样，默认策略使用的是：<code>InternalResourceViewResolver</code></p>
<p>同时，这也是 <code>demo</code> 中，我们手动配置的视图解析器</p>
<hr>
<h3 id="FlashMapManager-存储属性"><a href="#FlashMapManager-存储属性" class="headerlink" title="FlashMapManager 存储属性"></a>FlashMapManager 存储属性</h3><p>默认使用的是：<code>SessionFlashMapManager</code>，通过与 <code>FlashMap</code> 配合使用，<strong>用于在重定向时保存/传递参数</strong>。</p>
<p>例如 <code>Post/Redirect/Get</code> 模式，<code>Flash attribute</code> 在重定向之前暂存（根据类名，可以知道范围是 <code>session</code> 级别有效），以便重定向之后还能使用。</p>
<hr>
<h2 id="RequestMappingHandler"><a href="#RequestMappingHandler" class="headerlink" title="RequestMappingHandler"></a>RequestMappingHandler</h2><p><strong>该类作用：配合 <code>@Controller</code> 和 <code>@RequestMapping</code> 注解使用，通过 <code>URL</code> 来找到对应的处理器。</strong></p>
<p>前面在 <code>spring-mvc.xml</code> 文件加载时，初始化了两个重要配置，其中一个就是下面要说的 <code>RequestMappingHandler</code>，先来看它的继承体系图：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/request_mapping_handler_mapping_diagram.png" alt="request_mapping_handler_mapping_diagram"></p>
<p>从继承图中看到，它实现了 <code>InitializingBean</code> 接口，所以在初始化时，将会执行 <code>afterPropertiesSet</code> 方法（图片中注释写错方法，请以下面为准），核心调用的初始化方法是父类 <code>AbstractHandlerMethodMapping#initHandlerMethods</code> 方法</p>
<blockquote>
<p>AbstractHandlerMethodMapping#initHandlerMethods</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 获取容器中所有 bean 名字</span></div><div class="line">	<span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</div><div class="line">				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</div><div class="line">				obtainApplicationContext().getBeanNamesForType(Object.class)) &#123;</div><div class="line">		<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</div><div class="line">		    <span class="comment">// 如果前缀不是 scopedTarget.</span></div><div class="line">	        <span class="comment">// 执行 detectHandlerMethods() 方法</span></div><div class="line">			Class&lt;?&gt; beanType = obtainApplicationContext().getType(beanName);</div><div class="line">			<span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</div><div class="line">			    detectHandlerMethods(beanName);</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 打印数量，可以当成空实现</span></div><div class="line">	handlerMethodsInitialized(getHandlerMethods());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</div><div class="line">	Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</div><div class="line">			obtainApplicationContext().getType((String) handler) : handler.getClass());</div><div class="line">	<span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</div><div class="line">		Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</div><div class="line">		<span class="comment">// 通过反射，获取类中所有方法</span></div><div class="line">		<span class="comment">// 筛选出 public 类型，并且带有 @RequestMapping 注解的方法</span></div><div class="line">		Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</div><div class="line">				(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</div><div class="line">					<span class="comment">// 通过 RequestMappingHandlerMapping.getMappingForMethod 方法组装成 RequestMappingInfo（映射关系）</span></div><div class="line">					<span class="keyword">return</span> getMappingForMethod(method, userType);</div><div class="line">					</div><div class="line">			&#125;);</div><div class="line">		methods.forEach((method, mapping) -&gt; &#123;</div><div class="line">			Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</div><div class="line">			<span class="comment">// 通过 mappingRegistry 进行注册上面获取到的映射关系</span></div><div class="line">			registerHandlerMethod(handler, invocableMethod, mapping);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>梳理一下代码逻辑，<code>initHandlerMethods</code> 方法将会扫描注册 <code>bean</code> 下所有公共 <code>public</code> 方法，如果带有 <code>@RequestMapping</code> 注解的，将会组装成 <code>RequestMappingInfo</code> 映射关系，然后将它注册到 <code>mappingRegistry</code> 变量中。之后可以通过映射关系，输入 <code>URL</code> 就能够找到对应的处理器 <code>Controller</code>。</p>
<hr>
<h3 id="MappingRegistry"><a href="#MappingRegistry" class="headerlink" title="MappingRegistry"></a>MappingRegistry</h3><p><strong>该类是 <code>AbstractHandlerMethodMapping</code> 的内部类，是个工具类，用来保存所有 <code>Mapping</code> 和 <code>handler method</code>，通过暴露加锁的公共方法，避免了多线程对该类的内部变量的覆盖修改。</strong></p>
<p>下面是注册的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.readWriteLock.writeLock().lock();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 包装 bean 和方法</span></div><div class="line">		HandlerMethod handlerMethod = createHandlerMethod(handler, method);</div><div class="line">		<span class="comment">// 校验</span></div><div class="line">		validateMethodMapping(handlerMethod, mapping);</div><div class="line">		<span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</div><div class="line">		List&lt;String&gt; directUrls = getDirectUrls(mapping);</div><div class="line">		<span class="keyword">for</span> (String url : directUrls) &#123;</div><div class="line">			<span class="keyword">this</span>.urlLookup.add(url, mapping);</div><div class="line">		&#125;</div><div class="line">		String name = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</div><div class="line">			name = getNamingStrategy().getName(handlerMethod, mapping);</div><div class="line">			addMappingName(name, handlerMethod);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 跨域参数</span></div><div class="line">		CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</div><div class="line">		<span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 将映射关系放入  Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry</span></div><div class="line">		<span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">this</span>.readWriteLock.writeLock().unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/registry_mapping_method_mapping.png" alt=""></p>
<p>通过前面的包装和校验方法，最后映射关系将会放入这里 <code>Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry</code>。它是一个泛型的 <code>Map</code>，<strong><code>key</code> 类型是 <code>RequestMappingInfo</code>，保存了 <code>@RequestMapping</code> 各种属性的集合，<code>value</code> 类型是 <code>AbstractHandlerMethodMapping</code>，保存的是我们的映射关系。</strong></p>
<p><strong>从图中可以看出，如果输入的 <code>URL</code> 是 <code>/plain/{name}</code>，将会找到对应的处理方法 <code>web.controller.BookController#plain{String}</code>。</strong></p>
<hr>
<h2 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h2><p>而另一个重要的配置就是处理器适配器 <code>RequestMappingHandlerAdapter</code>，由于它的继承体系与 <code>RequestMappingHandler</code> 类似，所以我们直接来看它在加载时执行的方法</p>
<blockquote>
<p>RequestMappingHandlerAdapter#afterPropertiesSet</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 首先执行这个方法，可以添加 responseBody 切面 bean</span></div><div class="line">	initControllerAdviceCache();</div><div class="line">	<span class="comment">// 参数处理器</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</div><div class="line">		<span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 处理 initBinder 注解</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</div><div class="line">		<span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 初始化结果处理器</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">		List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</div><div class="line">		<span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以看到这个适配器中，初始化了很多工具变量，用来处理 <code>@ControllerAdvice</code> 、<code>InitBinder</code> 等注解和参数。不过核心还是待会要讲到的 <code>handleInternal()</code> 方法，它将适配处理器调用，然后返回 <code>ModelView</code> 视图。</strong></p>
<hr>
<h1 id="DispatcherServlet-的逻辑处理"><a href="#DispatcherServlet-的逻辑处理" class="headerlink" title="DispatcherServlet 的逻辑处理"></a>DispatcherServlet 的逻辑处理</h1><p>请求处理的入口定义在 <code>HttpServlet</code>，主要有以下几个方法：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/http_framework_servlet_enter.png" alt=""></p>
<p>当然，父类 <code>HttpServlet</code> 只是给出了定义，直接调用父类这些方法将会报错，所以 <code>FrameworkServlet</code> 将它们覆盖重写了处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</div><div class="line">	<span class="comment">// 注解 10. 具体调用的是 processRequest 方法</span></div><div class="line">	processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</div><div class="line">	processRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>可以看到 <code>doGet</code> 、<code>doPost</code> 这些方法，底层调用的都是 <code>processRequest</code> 方法进行处理，关键方法是委托给子类 <code>DispatcherServlet</code> 的 <code>doServie()</code> 方法</strong></p>
<blockquote>
<p>DispatcherServlet#doService</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	logRequest(request);</div><div class="line">	<span class="comment">// 暂存请求参数</span></div><div class="line">	Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</div><div class="line">	...</div><div class="line">	<span class="comment">// 经过前面的准备（属性、辅助变量），进入请求处理过程</span></div><div class="line">	doDispatch(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>请求分发和处理逻辑的核心是在 <code>doDispatch(request, response)</code> 方法中，在进入这个方法前，还有些准备工作需要执行。</strong></p>
<hr>
<h2 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h2><p>在 <code>processRequest</code> 的 <code>doServie()</code> 方法执行前，主要做了这以下准备工作：</p>
<p>（1） 为了保证当前线程的 <code>LocaleContext</code> 以及 <code>RequestAttributes</code> 可以在当前请求后还能恢复，提取当前线程的两个属性。<br>（2） 根据当前 <code>request</code> 创建对应的 <code>LocaleContext</code> 以及 <code>RequestAttributes</code>，绑定到当前线程<br>（3） 往 <code>request</code> 对象中设置之前加载过的 <code>localeResolver</code>、<code>flashMapManager</code> 等辅助工具变量</p>
<hr>
<h2 id="请求分发-doDispatch"><a href="#请求分发-doDispatch" class="headerlink" title="请求分发 doDispatch"></a>请求分发 doDispatch</h2><p>经过前面的配置设置，<code>doDispatch</code> 函数展示了请求的完成处理过程：</p>
<blockquote>
<p>DispatcherServlet#doDispatch</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</div><div class="line">	HttpServletRequest processedRequest = request;</div><div class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;	</div><div class="line">	<span class="comment">// 注释 10. 检查是否 MultipartContent 类型</span></div><div class="line">	processedRequest = checkMultipart(request);</div><div class="line">	<span class="comment">// 根据 request 信息寻找对应的 Handler</span></div><div class="line">	mappedHandler = getHandler(processedRequest);</div><div class="line">	<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 没有找到 handler，通过 response 向用户返回错误信息</span></div><div class="line">		noHandlerFound(processedRequest, response);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 根据当前的 handler 找到对应的 HandlerAdapter 适配器</span></div><div class="line">	HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">	<span class="comment">// 如果当前 handler 支持 last-modified 头处理</span></div><div class="line">	String method = request.getMethod();</div><div class="line">	<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">	<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">		<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 拦截器的 preHandler 方法的调用</span></div><div class="line">	<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 真正激活 handler 进行处理，并返回视图</span></div><div class="line">	mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">	<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 视图名称转换（有可能需要加上前后缀）</span></div><div class="line">	applyDefaultViewName(processedRequest, mv);</div><div class="line">	<span class="comment">// 应用所有拦截器的 postHandle 方法</span></div><div class="line">	mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">	<span class="comment">// 处理分发的结果（如果有 mv，进行视图渲染和跳转）</span></div><div class="line">	processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面贴出来的代码略有缩减，不过从上面示例中能看出，整体的逻辑都挺清晰的，主要步骤如下：</p>
<p><strong>1. 寻找处理器 <code>mappedandler</code></strong><br><strong>2. 根据处理器，寻找对应的适配器 <code>HandlerAdapter</code></strong><br><strong>3. 激活 <code>handler</code>，调用处理方法</strong><br><strong>4. 返回结果（如果有 mv，进行视图渲染和跳转）</strong></p>
<hr>
<h3 id="寻找处理器-mappedHandler"><a href="#寻找处理器-mappedHandler" class="headerlink" title="寻找处理器 mappedHandler"></a>寻找处理器 mappedHandler</h3><p><strong>以 <code>demo</code> 说明，寻找处理器，就是根据 <code>URL</code> 找到对应的 <code>Controller</code> 方法</strong></p>
<blockquote>
<p>DispatcherServlet#getHandler</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 遍历注册的全部 handlerMapping</span></div><div class="line">		<span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</div><div class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</div><div class="line">			<span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span> handler;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，在这一步遍历了所有注册的 <code>HandlerMapping</code>，然后委派它们去寻找处理器，如果找到了合适的，就不再往下寻找，直接返回。</p>
<p><strong>同时，<code>HandlerMapping</code> 之间有优先级的概念，根据 <code>mvc</code> 包下 <code>AnnotationDrivenBeanDefinitionParser</code> 的注释：</strong></p>
<blockquote>
<p><strong>This class registers the following {@link HandlerMapping HandlerMappings}</strong><br><strong>@link RequestMappingHandlerMapping</strong><br><strong>ordered at 0 for mapping requests to annotated controller methods.</strong></p>
</blockquote>
<p>说明了 <code>RequestMappingHandlerMapping</code> 的优先级是最高的，优先使用它来寻找适配器。</p>
<p>具体寻找调用的方法：</p>
<blockquote>
<p>AbstractHandlerMapping#getHandler</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// 根据 Request 获取对应的 handler</span></div><div class="line">	Object handler = getHandlerInternal(request);</div><div class="line">	<span class="comment">// 将配置中的对应拦截器加入到执行链中，以保证这些拦截器可以有效地作用于目标对象</span></div><div class="line">	HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</div><div class="line">	<span class="keyword">if</span> (hasCorsConfigurationSource(handler)) &#123;</div><div class="line">		CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</div><div class="line">		CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</div><div class="line">		config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</div><div class="line">		executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> executionChain;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(1) <code>getHandlerInternal(request)</code> 函数作用：</p>
<p>根据 <code>request</code> 信息获取对应的 <code>Handler</code>，也就是我们例子中的，通过 <code>URL</code> 找到匹配的 <code>Controller</code> 并返回。</p>
<p>(2) <code>getHandlerExcetionChain</code> 函数作用：</p>
<p>将适应该 <code>URL</code> 对应拦截器 <code>MappedInterceptor</code> 加入 <code>addInterceptor()</code> 到执行链 <code>HandlerExecutionChain</code> 中。</p>
<p>(3) <code>CorsConfiguration</code></p>
<p>这个参数涉及到跨域设置，具体看下这篇文章：<a href="https://blog.csdn.net/Colton_Null/article/details/75195230" target="_blank" rel="noopener">SpringBoot下如何配置实现跨域请求？</a></p>
<hr>
<h3 id="寻找适配器-HandlerAdapter"><a href="#寻找适配器-HandlerAdapter" class="headerlink" title="寻找适配器 HandlerAdapter"></a>寻找适配器 HandlerAdapter</h3><p>前面已经找到了对应的处理器了，下一步就得找到它对应的适配器</p>
<blockquote>
<p>DispatcherServlet#getHandlerAdapter</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span>  <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</div><div class="line">			<span class="keyword">if</span> (adapter.supports(handler)) &#123;</div><div class="line">				<span class="keyword">return</span> adapter;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，<code>HandlerAdapter</code> 之间也有优先级概念，由于第 0 位是 <code>RequestMappingHandlerAdapter</code>，而它的 <code>supports</code> 方法总是返回 <code>true</code>，所以毫无疑问返回了它</p>
<hr>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>通过适配器包装了一层，处理请求的入口如下：</p>
<blockquote>
<p>RequestMappingHandlerAdapter#handleInternal</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	ModelAndView mav;</div><div class="line">	checkRequest(request);</div><div class="line">	<span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</div><div class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</div><div class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</div><div class="line">			Object mutex = WebUtils.getSessionMutex(session);</div><div class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</div><div class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// No HttpSession available -&gt; no mutex necessary</span></div><div class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// No synchronization on session demanded at all...</span></div><div class="line">		<span class="comment">// 执行适配中真正的方法</span></div><div class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</div><div class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</div><div class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			prepareResponse(response);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mav;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>invokeHandlerMethod</code> 方法，调用对应的 <code>Controller</code> 方法逻辑，包装成 <code>ModelAndView</code>。</p>
<hr>
<h3 id="Session-代码块"><a href="#Session-代码块" class="headerlink" title="Session 代码块"></a>Session 代码块</h3><p><strong>判断 synchronizeOnSession 是否开启，开启的话，同一个 session 的请求将会串行执行（Object mutex = WebUtils.getSessionMutex(session)）</strong></p>
<hr>
<h3 id="自定义参数解析"><a href="#自定义参数解析" class="headerlink" title="自定义参数解析"></a>自定义参数解析</h3><p>解析逻辑由 <code>RequestParamMethodArgumentResolver</code> 完成，具体请查看 <a href="https://github.com/seaswalker/spring-analysis/blob/master/note/spring-mvc.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">spring-mvc</a></p>
<hr>
<h3 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h3><blockquote>
<p>InvocableHandlerMethod#invokeForRequest</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></div><div class="line"><span class="function"><span class="params">		Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class="line">	<span class="keyword">return</span> doInvoke(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过给定的参数，<code>doInvoke</code> 使用了反射操作，执行了 <code>Controller</code> 方法的逻辑。</p>
<hr>
<h3 id="返回值解析"><a href="#返回值解析" class="headerlink" title="返回值解析"></a>返回值解析</h3><p><strong>拿 <code>http://localhost:8080/bookView</code> 作为例子，经过前面的逻辑处理后，返回的只是试图名称 <code>bookView</code>，在这时，使用到了 <code>ViewNameMethodReturnValueHandler</code></strong></p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/view_name_method_return_value_handler_diagram.png" alt="view_name_method_return_value_handler_diagram"></p>
<p>可以看到它实现了 <code>HandlerMethodReturnValueHandler</code> 接口的两个方法</p>
<blockquote>
<p>ViewNameMethodReturnValueHandler#supportsReturnType; 表示支持处理的返回类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</div><div class="line">	Class&lt;?&gt; paramType = returnType.getParameterType();</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>.class == paramType || CharSequence.class.isAssignableFrom(paramType));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>ViewNameMethodReturnValueHandler#handleReturnValue; 返回处理值，给 mavContainer 设置视图名称 viewName</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></div><div class="line"><span class="function"><span class="params">		ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CharSequence) &#123;</div><div class="line">		String viewName = returnValue.toString();</div><div class="line">		mavContainer.setViewName(viewName);</div><div class="line">		<span class="keyword">if</span> (isRedirectViewName(viewName)) &#123;</div><div class="line">			mavContainer.setRedirectModelScenario(<span class="keyword">true</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>最后在适配器中包装成了 <code>ModelAndView</code> 对象</strong></p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/get_model_and_view_process.png" alt=""></p>
<hr>
<h2 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h2><p>根据处理器执行完成后，适配器包装成了 <code>ModelAndView</code> 返回给 <code>DispatcherServlet</code> 继续进行处理，来到了视图渲染的步骤：</p>
<blockquote>
<p>DispatcherServlet#processDispatchResult</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class="line"><span class="function"><span class="params">		@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></div><div class="line"><span class="function"><span class="params">		@Nullable Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">// 跳过了异常判断 =-=</span></div><div class="line">	<span class="comment">// Did the handler return a view to render?</span></div><div class="line">	<span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</div><div class="line">		<span class="comment">// 如果视图不为空并且 clear 属性为 false， 进行视图渲染</span></div><div class="line">		render(mv, request, response);</div><div class="line">		<span class="keyword">if</span> (errorView) &#123;</div><div class="line">			WebUtils.clearErrorRequestAttributes(request);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class="line">		<span class="comment">// Concurrent handling started during a forward</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">		mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>还记得我们使用的是 <code>jsp</code> 视图进行渲染么，引用的依赖是 <code>jstl</code>，所以视图渲染的是 <code>JstlView</code> 类提供的方法，以下是它的继承体系：</p>
<p><img src="https://gitee.com/vip-augus/blog-picture/raw/master/Spring/spring10/jstl_diagram.png" alt="jstl_diagram"></p>
<p>渲染调用的是其父类的方法：</p>
<blockquote>
<p>InternalResourceView#renderMergedOutputModel</p>
<p>在给定指定模型的情况下呈现内部资源。这包括将模型设置为请求属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// Expose the model object as request attributes.</span></div><div class="line">	exposeModelAsRequestAttributes(model, request);</div><div class="line">	<span class="comment">// Expose helpers as request attributes, if any.</span></div><div class="line">	exposeHelpers(request);</div><div class="line">	<span class="comment">// Determine the path for the request dispatcher.</span></div><div class="line">	String dispatcherPath = prepareForRendering(request, response);</div><div class="line">	<span class="comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span></div><div class="line">	RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</div><div class="line">	<span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">""</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// If already included or response already committed, perform include, else forward.</span></div><div class="line">	<span class="keyword">if</span> (useInclude(request, response)) &#123;</div><div class="line">		response.setContentType(getContentType());</div><div class="line">		rd.include(request, response);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// Note: The forwarded resource is supposed to determine the content type itself.</span></div><div class="line">		rd.forward(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后发现渲染调用的是第三方依赖 <code>org.apache.catalina.core.ApplicationDispatcher</code> 进行视图绘制，所以不再跟踪下去。</p>
<p><strong>所以整个视图渲染过程，就是在前面将 <code>Model</code> 视图对象中的属性设置到请求 <code>request</code> 中，最后通过原生（tomcat）的 <code>ApplicationDispatcher</code> 进行转发，渲染成视图。</strong></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇比较完整的描述了 <code>spring-mvc</code> 的框架体系，结合 <code>demo</code> 和代码，将调用链路梳理了一遍，了解了每个环节注册的工具类或解析器，了解了 <code>Spring</code> 容器和 <code>Web</code> 容器是如何合并使用，也了解到 <code>mvc</code> 初始化时加载的默认策略和请求完整的处理逻辑。</p>
<p>总结起来，就是我们在开头写下的内容：</p>
<p><strong>(1) 介绍如何使用</strong></p>
<p><strong>(2) 辅助工具类 <code>ContextLoaderContext</code></strong></p>
<p><strong>(3) <code>DispatcherServlet</code> 初始化</strong></p>
<p><strong>(4) <code>DispatcherServlet</code> 处理请求</strong></p>
<hr>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>本篇笔记写得比之前的都要吃力，<code>mvc</code> 模块基本使用了之前总结过的知识点，一边学一边复习之前的知识，而且由于个人在开发环境遇到了阻塞，<strong>秉着 [自己都不能成功运行的代码，是不能提交的] 原则</strong>，处理了挺长时间。</p>
<p>在跟踪每个知识点时，越深入发现坑越多，想要将它描述完整，在学习理解和总结中不断循环，所以本篇花了很多时间，同时也有很多知识点没有去深入学习，例如 <code>demo</code> 中出现的 <code>@RequestBody</code>、<code>@PathVarible</code> 等注解是如何解析和返回结果处理，留个坑。</p>
<p><strong>同时这篇笔记也是目前 <code>Spring</code> 源码学习的最后一篇技术总结，期望能得到朋友们的支持，如果写的不对的地方或者建议，请与我联系，我将完善和补充~</strong></p>
<hr>
<p><strong>由于个人技术有限，如果有理解不到位或者错误的地方，请留下评论，我会根据朋友们的建议进行修正</strong></p>
<p><a href="https://gitee.com/vip-augus/spring-analysis-note.git" target="_blank" rel="noopener">Gitee 地址 https://gitee.com/vip-augus/spring-analysis-note.git</a></p>
<p><a href="https://github.com/Vip-Augus/spring-analysis-note" target="_blank" rel="noopener">Github 地址 https://github.com/Vip-Augus/spring-analysis-note</a></p>
<hr>
<h1 id="传送门："><a href="#传送门：" class="headerlink" title="传送门："></a>传送门：</h1><ul>
<li><p><a href="https://vip-augus.github.io/2019/06/08/spring/2019-06-08-spring-analysis-note-env-prepared" target="_blank" rel="noopener">Spring 源码学习-环境准备</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/08/spring/2019-06-08-spring-analysis-note-1" target="_blank" rel="noopener">Spring 源码学习(一)容器的基础结构</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/14/spring/2019-06-14-spring-analysis-note-2" target="_blank" rel="noopener">Spring 源码学习(二)默认标签解析</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/16/spring/2019-06-16-spring-analysis-note-3" target="_blank" rel="noopener">Spring 源码学习(三)自定义标签</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/22/spring/2019-06-19-spring-analysis-note-4" target="_blank" rel="noopener">Spring 源码学习(四) bean 的加载</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/22/spring/2019-06-22-spring-analysis-note-5" target="_blank" rel="noopener">Spring 源码学习(五)循环依赖</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/22/spring/2019-06-22-spring-analysis-note-6" target="_blank" rel="noopener">Spring 源码学习(六)扩展功能 上篇</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/06/30/spring/2019-06-30-spring-analysis-note-7" target="_blank" rel="noopener">Spring 源码学习(七)扩展功能 下篇</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/07/17/spring/2019-07-17-spring-analysis-note-8" target="_blank" rel="noopener">Spring 源码学习(八) AOP 使用和实现原理</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/07/18/spring/2019-07-18-spring-analysis-note-9" target="_blank" rel="noopener">Spring 源码学习(九) Transaction 事务</a></p>
</li>
<li><p><a href="https://vip-augus.github.io/2019/07/21/spring/2019-07-21-spring-analysis-note-10" target="_blank" rel="noopener">Spring 源码学习(十) Spring mvc</a></p>
</li>
</ul>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/haerxiong/article/details/55666872" target="_blank" rel="noopener">idea中web.xml报错 Servlet should have a mapping</a></li>
<li><a href="https://blog.csdn.net/Thousa_Ho/article/details/70876854" target="_blank" rel="noopener">SpringMVC 使用总结</a></li>
<li><a href="https://www.jianshu.com/p/7fe31ea61dda" target="_blank" rel="noopener">idea 创建java web项目ssm-gradle</a></li>
<li><a href="https://book.douban.com/subject/25866350/" target="_blank" rel="noopener">Spring 源码深度解析 / 郝佳编著. – 北京 : 人民邮电出版社</a></li>
<li><a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">Spring MVC【入门】就这一篇！</a></li>
<li><a href="http://blog.didispace.com/books/spring-mvc-4-tutorial/publish/21-2/the-dispatcher-servlet.html" target="_blank" rel="noopener">DispatcherServlet</a></li>
<li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/spring-mvc.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">spring-mvc</a></li>
<li><a href="https://blog.csdn.net/Colton_Null/article/details/75195230" target="_blank" rel="noopener">SpringBoot下如何配置实现跨域请求？</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/18/spring/2019-07-18-spring-analysis-note-9/" rel="next" title="Spring 源码学习(九) Transaction 事务">
                <i class="fa fa-chevron-left"></i> Spring 源码学习(九) Transaction 事务
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/02/spring/2019-08-02-spring-analysis-artsdome/" rel="prev" title="Spring 源码学习总结篇">
                Spring 源码学习总结篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjEzNi8xMjY3MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://gitee.com/vip-augus/blog-picture/raw/master/panda.jpg"
               alt="JingQ" />
          <p class="site-author-name" itemprop="name">JingQ</p>
           
              <p class="site-description motion-element" itemprop="description">努力学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">95</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Vip-Augus" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/yjq41596" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/YeJingQi" target="_blank" title="Douban">
                  
                    <i class="fa fa-fw fa-anchor"></i>
                  
                    
                      Douban
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto://JingQBoom@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#如何使用"><span class="nav-number">1.</span> <span class="nav-text">如何使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ContextLoaderContext"><span class="nav-number">2.</span> <span class="nav-text">ContextLoaderContext</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DispatcherServlet-初始化"><span class="nav-number">3.</span> <span class="nav-text">DispatcherServlet 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器初始化"><span class="nav-number">3.1.</span> <span class="nav-text">容器初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebApplicationContext-的初始化"><span class="nav-number">3.1.1.</span> <span class="nav-text">WebApplicationContext 的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根容器查找"><span class="nav-number">3.1.2.</span> <span class="nav-text">根容器查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据-contextAttribute-寻找"><span class="nav-number">3.1.3.</span> <span class="nav-text">根据 contextAttribute 寻找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新创建实例"><span class="nav-number">3.1.4.</span> <span class="nav-text">重新创建实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取上下文类-contextClass"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">获取上下文类 contextClass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#configureAndRefreshWebApplicationContext"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">configureAndRefreshWebApplicationContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationContextInitializer"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">ApplicationContextInitializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载-Spring-配置"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">加载 Spring 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册-mvc-解析器"><span class="nav-number">3.1.4.5.</span> <span class="nav-text">注册 mvc 解析器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mvc-初始化"><span class="nav-number">3.2.</span> <span class="nav-text">mvc 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认策略"><span class="nav-number">3.2.1.</span> <span class="nav-text">默认策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multipartResolver-文件上传相关"><span class="nav-number">3.2.2.</span> <span class="nav-text">multipartResolver 文件上传相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalResolver-与国际化相关"><span class="nav-number">3.2.3.</span> <span class="nav-text">LocalResolver 与国际化相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThemeResolver-主题更换相关"><span class="nav-number">3.2.4.</span> <span class="nav-text">ThemeResolver 主题更换相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerMapping-与匹配处理器相关"><span class="nav-number">3.2.5.</span> <span class="nav-text">HandlerMapping 与匹配处理器相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerAdapter-适配器"><span class="nav-number">3.2.6.</span> <span class="nav-text">HandlerAdapter 适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerExceptionResolver-处理器异常解决器"><span class="nav-number">3.2.7.</span> <span class="nav-text">HandlerExceptionResolver 处理器异常解决器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestToViewNameTranslator-处理逻辑视图名称"><span class="nav-number">3.2.8.</span> <span class="nav-text">RequestToViewNameTranslator 处理逻辑视图名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewResolver-视图渲染"><span class="nav-number">3.2.9.</span> <span class="nav-text">ViewResolver 视图渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FlashMapManager-存储属性"><span class="nav-number">3.2.10.</span> <span class="nav-text">FlashMapManager 存储属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RequestMappingHandler"><span class="nav-number">3.3.</span> <span class="nav-text">RequestMappingHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MappingRegistry"><span class="nav-number">3.3.1.</span> <span class="nav-text">MappingRegistry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RequestMappingHandlerAdapter"><span class="nav-number">3.4.</span> <span class="nav-text">RequestMappingHandlerAdapter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DispatcherServlet-的逻辑处理"><span class="nav-number">4.</span> <span class="nav-text">DispatcherServlet 的逻辑处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#请求上下文"><span class="nav-number">4.1.</span> <span class="nav-text">请求上下文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分发-doDispatch"><span class="nav-number">4.2.</span> <span class="nav-text">请求分发 doDispatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找处理器-mappedHandler"><span class="nav-number">4.2.1.</span> <span class="nav-text">寻找处理器 mappedHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找适配器-HandlerAdapter"><span class="nav-number">4.2.2.</span> <span class="nav-text">寻找适配器 HandlerAdapter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求处理"><span class="nav-number">4.3.</span> <span class="nav-text">请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-代码块"><span class="nav-number">4.3.1.</span> <span class="nav-text">Session 代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义参数解析"><span class="nav-number">4.3.2.</span> <span class="nav-text">自定义参数解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑处理"><span class="nav-number">4.3.3.</span> <span class="nav-text">逻辑处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值解析"><span class="nav-number">4.3.4.</span> <span class="nav-text">返回值解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图渲染"><span class="nav-number">4.4.</span> <span class="nav-text">视图渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#render"><span class="nav-number">4.4.1.</span> <span class="nav-text">render</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题外话"><span class="nav-number">6.</span> <span class="nav-text">题外话</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传送门："><span class="nav-number">7.</span> <span class="nav-text">传送门：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-JingQ"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JingQ</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<a href="http://www.beian.miit.gov.cn">浙ICP备17002280号-1</a> 

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  





  

  

  

  

  

  

  
</body>
</html>
